
🥇 第 1 优先级：SQL 本身的优化（收益最大）
这些是性能瓶颈的 80% 来源。

慢 SQL 排查与优化：避免全表扫描、避免隐式转换

正确使用索引：覆盖索引、过滤索引、避免重复索引

统计信息更新：让优化器选对执行计划

避免大事务：减少锁等待

**避免 SELECT ***：减少 IO 和网络传输

SQL 优化是 MSSQL 性能提升最便宜、最有效的手段。


🥈 第 2 优先级：索引优化（立竿见影）
索引问题是性能慢的第二大元凶。

缺失索引：最常见瓶颈

索引碎片重建/重组

覆盖索引减少回表

列存储索引（Columnstore）：分析型查询神器

过滤索引：稀疏数据场景极其有效

索引优化通常能让查询从 10 秒 → 10 毫秒。



🥉 第 3 优先级：锁与并发优化（减少阻塞）
高并发系统最容易卡死在锁上。

RCSI / Snapshot 隔离级别：减少锁等待

拆小事务

避免表锁

避免串行化隔离级别

解决锁问题比加硬件更有效。


🥇 第 4 优先级：TempDB 优化（系统级瓶颈）
TempDB 是 MSSQL 的“公共厕所”，所有人都在用。

TempDB 多文件（通常 4–8 个）

TempDB 独立磁盘

减少临时表使用

TempDB 优化能解决 30% 的系统级性能问题。



🥇 第 5 优先级：存储与 IO 优化（硬件收益最大）
数据库性能的天花板就是 IO。

SSD / NVMe：最有效的硬件优化

日志文件独立磁盘

数据文件分布到多个 filegroup

IO 慢，什么都慢。

🥇 第 6 优先级：架构级优化（大表、大数据量场景）
适合你这种“单表很大”的情况。

分区表：减少扫描、加速维护

Filegroup 规划：冷热数据分离

列存储索引：报表查询提速几十倍

读写分离（AlwaysOn）

架构级优化适合 TB 级数据。

🥇 第 7 优先级：存储过程与执行计划优化
你之前提到的 SP、本地编译 SP 属于这一层。

SP（Stored Procedure）：减少网络往返

Native Compiled SP：极致性能

参数嗅探优化

Plan Guide / 强制计划

适合高频调用的关键 SQL。

🥇 第 8 优先级：缓存与配置优化
收益较小，但能锦上添花。

Optimize for ad hoc workloads

最大内存配置

并行度（MAXDOP）优化



🎯 最终优先级总结（最重要 → 次重要）

## io 优化
TempDB 优化

IO / 硬件优化

架构级优化（分区、filegroup）

## sql
SQL 优化（收益最大）

## 索引优化

## 锁与并发优化



存储过程优化

缓存与配置优化

你只要按这个顺序做，性能问题基本都能解决。