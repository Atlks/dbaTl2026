

🚀 真正能把 10 TPS → 1000+ TPS 的方法
这些才是关键：

1. 分片（Sharding）余额表
   按用户 ID、账户 ID、业务线拆分。

2. 使用行版本化（RCSI）减少读写冲突
   sql
   ALTER DATABASE YourDB SET READ_COMMITTED_SNAPSHOT ON;
3. 使用乐观并发（版本号 / 时间戳）  内存表
   sql
   UPDATE Account
   SET Balance = Balance + @Amount
   WHERE Id = @Id AND RowVersion = @OldVersion;
4. 使用队列化写入（异步聚合）
   把更新写入队列，由后台批量处理。

5. 使用内存 OLTP（Hekaton）
   单行更新可达 几十万 TPS。

6. 使用分布式缓存（Redis）做余额增量
   最终一致性写回 SQL。


查询是否启用  READ_COMMITTED_SNAPSHOT
要检查数据库是否启用了 READ_COMMITTED_SNAPSHOT (RCSI)，SQL Server 提供了一个非常直接、可靠的查询方式。下面给你最常用、最准确的写法。

🔍 查询数据库是否启用 READ_COMMITTED_SNAPSHOT
sql
SELECT
name,
is_read_committed_snapshot_on
FROM sys.databases
WHERE name = 'hxpay';
结果含义：

is_read_committed_snapshot_on = 1 → 已启用

is_read_committed_snapshot_on = 0 → 未启用

每一项都值得你关注，因为它直接决定你的读写并发模型。



SELECT
name,
snapshot_isolation_state_desc,
is_read_committed_snapshot_on
FROM sys.databases
WHERE name = 'hxpay';



🎯 那 RCSI（READ_COMMITTED_SNAPSHOT）呢？
✔️ RCSI 对你有帮助，但帮助有限
它能解决：

读写冲突

SELECT 阻塞 UPDATE

UPDATE 阻塞 SELECT

大量读导致的锁争用

但它 不能解决写写冲突。

你现在的问题是：

同一行被频繁更新 → 写写冲突 → 串行化 → TPS 只有 10

这是架构层面的瓶颈，不是隔离级别能解决的。



SNAPSHOT ISOLATION（数据库级）不适合单行高频更新

应用层乐观并发（版本号）非常适合单行高频更新

🧩 两种“乐观并发”其实不是同一个东西
① SNAPSHOT ISOLATION（数据库级）


② 应用层乐观并发（UPDATE 0 行）
UPDATE 时带版本号或时间戳

如果版本不匹配 → UPDATE 0 行

不抛异常

不回滚整个事务

那么内存表呢
内存表（Memory‑Optimized Table / Hekaton）确实能大幅提升单行高频更新的 TPS，但它能不能解决你现在的“单行余额更新只有 10 TPS”这个问题，要看你遇到的瓶颈是哪一种。